Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declarations
Rule 2     declarations -> declarations declaration
Rule 3     declarations -> declaration
Rule 4     declaration -> var_decl SEMICOLON
Rule 5     declaration -> function_decl
Rule 6     var_decl -> type IDENTIFIER
Rule 7     var_decl -> type IDENTIFIER ASSIGN expression
Rule 8     type -> INT
Rule 9     type -> FLOAT
Rule 10    type -> CHAR_TYPE
Rule 11    type -> VOID
Rule 12    function_decl -> type IDENTIFIER LPAREN params RPAREN block
Rule 13    params -> param_list
Rule 14    params -> empty
Rule 15    param_list -> param_list COMMA param
Rule 16    param_list -> param
Rule 17    param -> type IDENTIFIER
Rule 18    block -> LBRACE statements RBRACE
Rule 19    statements -> statements statement
Rule 20    statements -> empty
Rule 21    statement -> expression_statement
Rule 22    statement -> var_decl SEMICOLON
Rule 23    statement -> if_statement
Rule 24    statement -> while_statement
Rule 25    statement -> for_statement
Rule 26    statement -> return_statement
Rule 27    statement -> block
Rule 28    expression_statement -> expression SEMICOLON
Rule 29    expression_statement -> SEMICOLON
Rule 30    if_statement -> IF LPAREN expression RPAREN statement
Rule 31    if_statement -> IF LPAREN expression RPAREN statement ELSE statement
Rule 32    while_statement -> WHILE LPAREN expression RPAREN statement
Rule 33    for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement
Rule 34    for_init -> var_decl
Rule 35    for_init -> expression
Rule 36    for_init -> empty
Rule 37    for_cond -> expression
Rule 38    for_cond -> empty
Rule 39    for_update -> expression
Rule 40    for_update -> empty
Rule 41    return_statement -> RETURN expression SEMICOLON
Rule 42    return_statement -> RETURN SEMICOLON
Rule 43    expression -> expression PLUS expression
Rule 44    expression -> expression MINUS expression
Rule 45    expression -> expression MULTIPLY expression
Rule 46    expression -> expression DIVIDE expression
Rule 47    expression -> expression EQ expression
Rule 48    expression -> expression NE expression
Rule 49    expression -> expression LT expression
Rule 50    expression -> expression GT expression
Rule 51    expression -> expression LE expression
Rule 52    expression -> expression GE expression
Rule 53    expression -> expression AND expression
Rule 54    expression -> expression OR expression
Rule 55    expression -> NOT expression
Rule 56    expression -> MINUS expression
Rule 57    expression -> LPAREN expression RPAREN
Rule 58    expression -> IDENTIFIER ASSIGN expression
Rule 59    expression -> primary
Rule 60    primary -> INTEGER
Rule 61    primary -> FLOAT_NUMBER
Rule 62    primary -> STRING
Rule 63    primary -> CHAR
Rule 64    primary -> IDENTIFIER
Rule 65    primary -> function_call
Rule 66    function_call -> IDENTIFIER LPAREN args RPAREN
Rule 67    args -> arg_list
Rule 68    args -> empty
Rule 69    arg_list -> arg_list COMMA expression
Rule 70    arg_list -> expression
Rule 71    empty -> <empty>

Terminals, with rules where they appear

AND                  : 53
ASSIGN               : 7 58
CHAR                 : 63
CHAR_TYPE            : 10
COMMA                : 15 69
DIVIDE               : 46
ELSE                 : 31
EQ                   : 47
FLOAT                : 9
FLOAT_NUMBER         : 61
FOR                  : 33
GE                   : 52
GT                   : 50
IDENTIFIER           : 6 7 12 17 58 64 66
IF                   : 30 31
INT                  : 8
INTEGER              : 60
LBRACE               : 18
LE                   : 51
LPAREN               : 12 30 31 32 33 57 66
LT                   : 49
MINUS                : 44 56
MULTIPLY             : 45
NE                   : 48
NOT                  : 55
OR                   : 54
PLUS                 : 43
RBRACE               : 18
RETURN               : 41 42
RPAREN               : 12 30 31 32 33 57 66
SEMICOLON            : 4 22 28 29 33 33 41 42
STRING               : 62
VOID                 : 11
WHILE                : 32
error                : 

Nonterminals, with rules where they appear

arg_list             : 67 69
args                 : 66
block                : 12 27
declaration          : 2 3
declarations         : 1 2
empty                : 14 20 36 38 40 68
expression           : 7 28 30 31 32 35 37 39 41 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 56 57 58 69 70
expression_statement : 21
for_cond             : 33
for_init             : 33
for_statement        : 25
for_update           : 33
function_call        : 65
function_decl        : 5
if_statement         : 23
param                : 15 16
param_list           : 13 15
params               : 12
primary              : 59
program              : 0
return_statement     : 26
statement            : 19 30 31 31 32 33
statements           : 18 19
type                 : 6 7 12 17
var_decl             : 4 22 34
while_statement      : 24

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declarations
    (2) declarations -> . declarations declaration
    (3) declarations -> . declaration
    (4) declaration -> . var_decl SEMICOLON
    (5) declaration -> . function_decl
    (6) var_decl -> . type IDENTIFIER
    (7) var_decl -> . type IDENTIFIER ASSIGN expression
    (12) function_decl -> . type IDENTIFIER LPAREN params RPAREN block
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . CHAR_TYPE
    (11) type -> . VOID

    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR_TYPE       shift and go to state 9
    VOID            shift and go to state 10

    program                        shift and go to state 1
    declarations                   shift and go to state 2
    declaration                    shift and go to state 3
    var_decl                       shift and go to state 4
    function_decl                  shift and go to state 5
    type                           shift and go to state 6

state 1

    (0) S' -> program .



state 2

    (1) program -> declarations .
    (2) declarations -> declarations . declaration
    (4) declaration -> . var_decl SEMICOLON
    (5) declaration -> . function_decl
    (6) var_decl -> . type IDENTIFIER
    (7) var_decl -> . type IDENTIFIER ASSIGN expression
    (12) function_decl -> . type IDENTIFIER LPAREN params RPAREN block
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . CHAR_TYPE
    (11) type -> . VOID

    $end            reduce using rule 1 (program -> declarations .)
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR_TYPE       shift and go to state 9
    VOID            shift and go to state 10

    declaration                    shift and go to state 11
    var_decl                       shift and go to state 4
    function_decl                  shift and go to state 5
    type                           shift and go to state 6

state 3

    (3) declarations -> declaration .

    INT             reduce using rule 3 (declarations -> declaration .)
    FLOAT           reduce using rule 3 (declarations -> declaration .)
    CHAR_TYPE       reduce using rule 3 (declarations -> declaration .)
    VOID            reduce using rule 3 (declarations -> declaration .)
    $end            reduce using rule 3 (declarations -> declaration .)


state 4

    (4) declaration -> var_decl . SEMICOLON

    SEMICOLON       shift and go to state 12


state 5

    (5) declaration -> function_decl .

    INT             reduce using rule 5 (declaration -> function_decl .)
    FLOAT           reduce using rule 5 (declaration -> function_decl .)
    CHAR_TYPE       reduce using rule 5 (declaration -> function_decl .)
    VOID            reduce using rule 5 (declaration -> function_decl .)
    $end            reduce using rule 5 (declaration -> function_decl .)


state 6

    (6) var_decl -> type . IDENTIFIER
    (7) var_decl -> type . IDENTIFIER ASSIGN expression
    (12) function_decl -> type . IDENTIFIER LPAREN params RPAREN block

    IDENTIFIER      shift and go to state 13


state 7

    (8) type -> INT .

    IDENTIFIER      reduce using rule 8 (type -> INT .)


state 8

    (9) type -> FLOAT .

    IDENTIFIER      reduce using rule 9 (type -> FLOAT .)


state 9

    (10) type -> CHAR_TYPE .

    IDENTIFIER      reduce using rule 10 (type -> CHAR_TYPE .)


state 10

    (11) type -> VOID .

    IDENTIFIER      reduce using rule 11 (type -> VOID .)


state 11

    (2) declarations -> declarations declaration .

    INT             reduce using rule 2 (declarations -> declarations declaration .)
    FLOAT           reduce using rule 2 (declarations -> declarations declaration .)
    CHAR_TYPE       reduce using rule 2 (declarations -> declarations declaration .)
    VOID            reduce using rule 2 (declarations -> declarations declaration .)
    $end            reduce using rule 2 (declarations -> declarations declaration .)


state 12

    (4) declaration -> var_decl SEMICOLON .

    INT             reduce using rule 4 (declaration -> var_decl SEMICOLON .)
    FLOAT           reduce using rule 4 (declaration -> var_decl SEMICOLON .)
    CHAR_TYPE       reduce using rule 4 (declaration -> var_decl SEMICOLON .)
    VOID            reduce using rule 4 (declaration -> var_decl SEMICOLON .)
    $end            reduce using rule 4 (declaration -> var_decl SEMICOLON .)


state 13

    (6) var_decl -> type IDENTIFIER .
    (7) var_decl -> type IDENTIFIER . ASSIGN expression
    (12) function_decl -> type IDENTIFIER . LPAREN params RPAREN block

    SEMICOLON       reduce using rule 6 (var_decl -> type IDENTIFIER .)
    ASSIGN          shift and go to state 14
    LPAREN          shift and go to state 15


state 14

    (7) var_decl -> type IDENTIFIER ASSIGN . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 17
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 15

    (12) function_decl -> type IDENTIFIER LPAREN . params RPAREN block
    (13) params -> . param_list
    (14) params -> . empty
    (15) param_list -> . param_list COMMA param
    (16) param_list -> . param
    (71) empty -> .
    (17) param -> . type IDENTIFIER
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . CHAR_TYPE
    (11) type -> . VOID

    RPAREN          reduce using rule 71 (empty -> .)
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR_TYPE       shift and go to state 9
    VOID            shift and go to state 10

    type                           shift and go to state 27
    params                         shift and go to state 28
    param_list                     shift and go to state 29
    empty                          shift and go to state 30
    param                          shift and go to state 31

state 16

    (58) expression -> IDENTIFIER . ASSIGN expression
    (64) primary -> IDENTIFIER .
    (66) function_call -> IDENTIFIER . LPAREN args RPAREN

    ASSIGN          shift and go to state 32
    PLUS            reduce using rule 64 (primary -> IDENTIFIER .)
    MINUS           reduce using rule 64 (primary -> IDENTIFIER .)
    MULTIPLY        reduce using rule 64 (primary -> IDENTIFIER .)
    DIVIDE          reduce using rule 64 (primary -> IDENTIFIER .)
    EQ              reduce using rule 64 (primary -> IDENTIFIER .)
    NE              reduce using rule 64 (primary -> IDENTIFIER .)
    LT              reduce using rule 64 (primary -> IDENTIFIER .)
    GT              reduce using rule 64 (primary -> IDENTIFIER .)
    LE              reduce using rule 64 (primary -> IDENTIFIER .)
    GE              reduce using rule 64 (primary -> IDENTIFIER .)
    AND             reduce using rule 64 (primary -> IDENTIFIER .)
    OR              reduce using rule 64 (primary -> IDENTIFIER .)
    SEMICOLON       reduce using rule 64 (primary -> IDENTIFIER .)
    RPAREN          reduce using rule 64 (primary -> IDENTIFIER .)
    COMMA           reduce using rule 64 (primary -> IDENTIFIER .)
    LPAREN          shift and go to state 33


state 17

    (7) var_decl -> type IDENTIFIER ASSIGN expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    SEMICOLON       reduce using rule 7 (var_decl -> type IDENTIFIER ASSIGN expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    EQ              shift and go to state 38
    NE              shift and go to state 39
    LT              shift and go to state 40
    GT              shift and go to state 41
    LE              shift and go to state 42
    GE              shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 18

    (56) expression -> MINUS . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 46
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 19

    (55) expression -> NOT . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 47
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 20

    (57) expression -> LPAREN . expression RPAREN
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 48
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 21

    (59) expression -> primary .

    PLUS            reduce using rule 59 (expression -> primary .)
    MINUS           reduce using rule 59 (expression -> primary .)
    MULTIPLY        reduce using rule 59 (expression -> primary .)
    DIVIDE          reduce using rule 59 (expression -> primary .)
    EQ              reduce using rule 59 (expression -> primary .)
    NE              reduce using rule 59 (expression -> primary .)
    LT              reduce using rule 59 (expression -> primary .)
    GT              reduce using rule 59 (expression -> primary .)
    LE              reduce using rule 59 (expression -> primary .)
    GE              reduce using rule 59 (expression -> primary .)
    AND             reduce using rule 59 (expression -> primary .)
    OR              reduce using rule 59 (expression -> primary .)
    SEMICOLON       reduce using rule 59 (expression -> primary .)
    RPAREN          reduce using rule 59 (expression -> primary .)
    COMMA           reduce using rule 59 (expression -> primary .)


state 22

    (60) primary -> INTEGER .

    PLUS            reduce using rule 60 (primary -> INTEGER .)
    MINUS           reduce using rule 60 (primary -> INTEGER .)
    MULTIPLY        reduce using rule 60 (primary -> INTEGER .)
    DIVIDE          reduce using rule 60 (primary -> INTEGER .)
    EQ              reduce using rule 60 (primary -> INTEGER .)
    NE              reduce using rule 60 (primary -> INTEGER .)
    LT              reduce using rule 60 (primary -> INTEGER .)
    GT              reduce using rule 60 (primary -> INTEGER .)
    LE              reduce using rule 60 (primary -> INTEGER .)
    GE              reduce using rule 60 (primary -> INTEGER .)
    AND             reduce using rule 60 (primary -> INTEGER .)
    OR              reduce using rule 60 (primary -> INTEGER .)
    SEMICOLON       reduce using rule 60 (primary -> INTEGER .)
    RPAREN          reduce using rule 60 (primary -> INTEGER .)
    COMMA           reduce using rule 60 (primary -> INTEGER .)


state 23

    (61) primary -> FLOAT_NUMBER .

    PLUS            reduce using rule 61 (primary -> FLOAT_NUMBER .)
    MINUS           reduce using rule 61 (primary -> FLOAT_NUMBER .)
    MULTIPLY        reduce using rule 61 (primary -> FLOAT_NUMBER .)
    DIVIDE          reduce using rule 61 (primary -> FLOAT_NUMBER .)
    EQ              reduce using rule 61 (primary -> FLOAT_NUMBER .)
    NE              reduce using rule 61 (primary -> FLOAT_NUMBER .)
    LT              reduce using rule 61 (primary -> FLOAT_NUMBER .)
    GT              reduce using rule 61 (primary -> FLOAT_NUMBER .)
    LE              reduce using rule 61 (primary -> FLOAT_NUMBER .)
    GE              reduce using rule 61 (primary -> FLOAT_NUMBER .)
    AND             reduce using rule 61 (primary -> FLOAT_NUMBER .)
    OR              reduce using rule 61 (primary -> FLOAT_NUMBER .)
    SEMICOLON       reduce using rule 61 (primary -> FLOAT_NUMBER .)
    RPAREN          reduce using rule 61 (primary -> FLOAT_NUMBER .)
    COMMA           reduce using rule 61 (primary -> FLOAT_NUMBER .)


state 24

    (62) primary -> STRING .

    PLUS            reduce using rule 62 (primary -> STRING .)
    MINUS           reduce using rule 62 (primary -> STRING .)
    MULTIPLY        reduce using rule 62 (primary -> STRING .)
    DIVIDE          reduce using rule 62 (primary -> STRING .)
    EQ              reduce using rule 62 (primary -> STRING .)
    NE              reduce using rule 62 (primary -> STRING .)
    LT              reduce using rule 62 (primary -> STRING .)
    GT              reduce using rule 62 (primary -> STRING .)
    LE              reduce using rule 62 (primary -> STRING .)
    GE              reduce using rule 62 (primary -> STRING .)
    AND             reduce using rule 62 (primary -> STRING .)
    OR              reduce using rule 62 (primary -> STRING .)
    SEMICOLON       reduce using rule 62 (primary -> STRING .)
    RPAREN          reduce using rule 62 (primary -> STRING .)
    COMMA           reduce using rule 62 (primary -> STRING .)


state 25

    (63) primary -> CHAR .

    PLUS            reduce using rule 63 (primary -> CHAR .)
    MINUS           reduce using rule 63 (primary -> CHAR .)
    MULTIPLY        reduce using rule 63 (primary -> CHAR .)
    DIVIDE          reduce using rule 63 (primary -> CHAR .)
    EQ              reduce using rule 63 (primary -> CHAR .)
    NE              reduce using rule 63 (primary -> CHAR .)
    LT              reduce using rule 63 (primary -> CHAR .)
    GT              reduce using rule 63 (primary -> CHAR .)
    LE              reduce using rule 63 (primary -> CHAR .)
    GE              reduce using rule 63 (primary -> CHAR .)
    AND             reduce using rule 63 (primary -> CHAR .)
    OR              reduce using rule 63 (primary -> CHAR .)
    SEMICOLON       reduce using rule 63 (primary -> CHAR .)
    RPAREN          reduce using rule 63 (primary -> CHAR .)
    COMMA           reduce using rule 63 (primary -> CHAR .)


state 26

    (65) primary -> function_call .

    PLUS            reduce using rule 65 (primary -> function_call .)
    MINUS           reduce using rule 65 (primary -> function_call .)
    MULTIPLY        reduce using rule 65 (primary -> function_call .)
    DIVIDE          reduce using rule 65 (primary -> function_call .)
    EQ              reduce using rule 65 (primary -> function_call .)
    NE              reduce using rule 65 (primary -> function_call .)
    LT              reduce using rule 65 (primary -> function_call .)
    GT              reduce using rule 65 (primary -> function_call .)
    LE              reduce using rule 65 (primary -> function_call .)
    GE              reduce using rule 65 (primary -> function_call .)
    AND             reduce using rule 65 (primary -> function_call .)
    OR              reduce using rule 65 (primary -> function_call .)
    SEMICOLON       reduce using rule 65 (primary -> function_call .)
    RPAREN          reduce using rule 65 (primary -> function_call .)
    COMMA           reduce using rule 65 (primary -> function_call .)


state 27

    (17) param -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 49


state 28

    (12) function_decl -> type IDENTIFIER LPAREN params . RPAREN block

    RPAREN          shift and go to state 50


state 29

    (13) params -> param_list .
    (15) param_list -> param_list . COMMA param

    RPAREN          reduce using rule 13 (params -> param_list .)
    COMMA           shift and go to state 51


state 30

    (14) params -> empty .

    RPAREN          reduce using rule 14 (params -> empty .)


state 31

    (16) param_list -> param .

    COMMA           reduce using rule 16 (param_list -> param .)
    RPAREN          reduce using rule 16 (param_list -> param .)


state 32

    (58) expression -> IDENTIFIER ASSIGN . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 52
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 33

    (66) function_call -> IDENTIFIER LPAREN . args RPAREN
    (67) args -> . arg_list
    (68) args -> . empty
    (69) arg_list -> . arg_list COMMA expression
    (70) arg_list -> . expression
    (71) empty -> .
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    RPAREN          reduce using rule 71 (empty -> .)
    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    args                           shift and go to state 53
    arg_list                       shift and go to state 54
    empty                          shift and go to state 55
    expression                     shift and go to state 56
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 34

    (43) expression -> expression PLUS . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 57
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 35

    (44) expression -> expression MINUS . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 58
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 36

    (45) expression -> expression MULTIPLY . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 59
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 37

    (46) expression -> expression DIVIDE . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 60
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 38

    (47) expression -> expression EQ . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 61
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 39

    (48) expression -> expression NE . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 62
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 40

    (49) expression -> expression LT . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 63
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 41

    (50) expression -> expression GT . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 64
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 42

    (51) expression -> expression LE . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 65
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 43

    (52) expression -> expression GE . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 66
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 44

    (53) expression -> expression AND . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 67
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 45

    (54) expression -> expression OR . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 68
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 46

    (56) expression -> MINUS expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    PLUS            reduce using rule 56 (expression -> MINUS expression .)
    MINUS           reduce using rule 56 (expression -> MINUS expression .)
    MULTIPLY        reduce using rule 56 (expression -> MINUS expression .)
    DIVIDE          reduce using rule 56 (expression -> MINUS expression .)
    EQ              reduce using rule 56 (expression -> MINUS expression .)
    NE              reduce using rule 56 (expression -> MINUS expression .)
    LT              reduce using rule 56 (expression -> MINUS expression .)
    GT              reduce using rule 56 (expression -> MINUS expression .)
    LE              reduce using rule 56 (expression -> MINUS expression .)
    GE              reduce using rule 56 (expression -> MINUS expression .)
    AND             reduce using rule 56 (expression -> MINUS expression .)
    OR              reduce using rule 56 (expression -> MINUS expression .)
    SEMICOLON       reduce using rule 56 (expression -> MINUS expression .)
    RPAREN          reduce using rule 56 (expression -> MINUS expression .)
    COMMA           reduce using rule 56 (expression -> MINUS expression .)

  ! PLUS            [ shift and go to state 34 ]
  ! MINUS           [ shift and go to state 35 ]
  ! MULTIPLY        [ shift and go to state 36 ]
  ! DIVIDE          [ shift and go to state 37 ]
  ! EQ              [ shift and go to state 38 ]
  ! NE              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GT              [ shift and go to state 41 ]
  ! LE              [ shift and go to state 42 ]
  ! GE              [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 47

    (55) expression -> NOT expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    PLUS            reduce using rule 55 (expression -> NOT expression .)
    MINUS           reduce using rule 55 (expression -> NOT expression .)
    MULTIPLY        reduce using rule 55 (expression -> NOT expression .)
    DIVIDE          reduce using rule 55 (expression -> NOT expression .)
    EQ              reduce using rule 55 (expression -> NOT expression .)
    NE              reduce using rule 55 (expression -> NOT expression .)
    LT              reduce using rule 55 (expression -> NOT expression .)
    GT              reduce using rule 55 (expression -> NOT expression .)
    LE              reduce using rule 55 (expression -> NOT expression .)
    GE              reduce using rule 55 (expression -> NOT expression .)
    AND             reduce using rule 55 (expression -> NOT expression .)
    OR              reduce using rule 55 (expression -> NOT expression .)
    SEMICOLON       reduce using rule 55 (expression -> NOT expression .)
    RPAREN          reduce using rule 55 (expression -> NOT expression .)
    COMMA           reduce using rule 55 (expression -> NOT expression .)

  ! PLUS            [ shift and go to state 34 ]
  ! MINUS           [ shift and go to state 35 ]
  ! MULTIPLY        [ shift and go to state 36 ]
  ! DIVIDE          [ shift and go to state 37 ]
  ! EQ              [ shift and go to state 38 ]
  ! NE              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GT              [ shift and go to state 41 ]
  ! LE              [ shift and go to state 42 ]
  ! GE              [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 48

    (57) expression -> LPAREN expression . RPAREN
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    RPAREN          shift and go to state 69
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    EQ              shift and go to state 38
    NE              shift and go to state 39
    LT              shift and go to state 40
    GT              shift and go to state 41
    LE              shift and go to state 42
    GE              shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 49

    (17) param -> type IDENTIFIER .

    COMMA           reduce using rule 17 (param -> type IDENTIFIER .)
    RPAREN          reduce using rule 17 (param -> type IDENTIFIER .)


state 50

    (12) function_decl -> type IDENTIFIER LPAREN params RPAREN . block
    (18) block -> . LBRACE statements RBRACE

    LBRACE          shift and go to state 71

    block                          shift and go to state 70

state 51

    (15) param_list -> param_list COMMA . param
    (17) param -> . type IDENTIFIER
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . CHAR_TYPE
    (11) type -> . VOID

    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR_TYPE       shift and go to state 9
    VOID            shift and go to state 10

    param                          shift and go to state 72
    type                           shift and go to state 27

state 52

    (58) expression -> IDENTIFIER ASSIGN expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 58 (expression -> IDENTIFIER ASSIGN expression .)
    RPAREN          reduce using rule 58 (expression -> IDENTIFIER ASSIGN expression .)
    COMMA           reduce using rule 58 (expression -> IDENTIFIER ASSIGN expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    EQ              shift and go to state 38
    NE              shift and go to state 39
    LT              shift and go to state 40
    GT              shift and go to state 41
    LE              shift and go to state 42
    GE              shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45

  ! PLUS            [ reduce using rule 58 (expression -> IDENTIFIER ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 58 (expression -> IDENTIFIER ASSIGN expression .) ]
  ! MULTIPLY        [ reduce using rule 58 (expression -> IDENTIFIER ASSIGN expression .) ]
  ! DIVIDE          [ reduce using rule 58 (expression -> IDENTIFIER ASSIGN expression .) ]
  ! EQ              [ reduce using rule 58 (expression -> IDENTIFIER ASSIGN expression .) ]
  ! NE              [ reduce using rule 58 (expression -> IDENTIFIER ASSIGN expression .) ]
  ! LT              [ reduce using rule 58 (expression -> IDENTIFIER ASSIGN expression .) ]
  ! GT              [ reduce using rule 58 (expression -> IDENTIFIER ASSIGN expression .) ]
  ! LE              [ reduce using rule 58 (expression -> IDENTIFIER ASSIGN expression .) ]
  ! GE              [ reduce using rule 58 (expression -> IDENTIFIER ASSIGN expression .) ]
  ! AND             [ reduce using rule 58 (expression -> IDENTIFIER ASSIGN expression .) ]
  ! OR              [ reduce using rule 58 (expression -> IDENTIFIER ASSIGN expression .) ]


state 53

    (66) function_call -> IDENTIFIER LPAREN args . RPAREN

    RPAREN          shift and go to state 73


state 54

    (67) args -> arg_list .
    (69) arg_list -> arg_list . COMMA expression

    RPAREN          reduce using rule 67 (args -> arg_list .)
    COMMA           shift and go to state 74


state 55

    (68) args -> empty .

    RPAREN          reduce using rule 68 (args -> empty .)


state 56

    (70) arg_list -> expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    COMMA           reduce using rule 70 (arg_list -> expression .)
    RPAREN          reduce using rule 70 (arg_list -> expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    EQ              shift and go to state 38
    NE              shift and go to state 39
    LT              shift and go to state 40
    GT              shift and go to state 41
    LE              shift and go to state 42
    GE              shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 57

    (43) expression -> expression PLUS expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    PLUS            reduce using rule 43 (expression -> expression PLUS expression .)
    MINUS           reduce using rule 43 (expression -> expression PLUS expression .)
    EQ              reduce using rule 43 (expression -> expression PLUS expression .)
    NE              reduce using rule 43 (expression -> expression PLUS expression .)
    LT              reduce using rule 43 (expression -> expression PLUS expression .)
    GT              reduce using rule 43 (expression -> expression PLUS expression .)
    LE              reduce using rule 43 (expression -> expression PLUS expression .)
    GE              reduce using rule 43 (expression -> expression PLUS expression .)
    AND             reduce using rule 43 (expression -> expression PLUS expression .)
    OR              reduce using rule 43 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 43 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 43 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 43 (expression -> expression PLUS expression .)
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37

  ! MULTIPLY        [ reduce using rule 43 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 43 (expression -> expression PLUS expression .) ]
  ! PLUS            [ shift and go to state 34 ]
  ! MINUS           [ shift and go to state 35 ]
  ! EQ              [ shift and go to state 38 ]
  ! NE              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GT              [ shift and go to state 41 ]
  ! LE              [ shift and go to state 42 ]
  ! GE              [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 58

    (44) expression -> expression MINUS expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    PLUS            reduce using rule 44 (expression -> expression MINUS expression .)
    MINUS           reduce using rule 44 (expression -> expression MINUS expression .)
    EQ              reduce using rule 44 (expression -> expression MINUS expression .)
    NE              reduce using rule 44 (expression -> expression MINUS expression .)
    LT              reduce using rule 44 (expression -> expression MINUS expression .)
    GT              reduce using rule 44 (expression -> expression MINUS expression .)
    LE              reduce using rule 44 (expression -> expression MINUS expression .)
    GE              reduce using rule 44 (expression -> expression MINUS expression .)
    AND             reduce using rule 44 (expression -> expression MINUS expression .)
    OR              reduce using rule 44 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 44 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 44 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 44 (expression -> expression MINUS expression .)
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37

  ! MULTIPLY        [ reduce using rule 44 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 44 (expression -> expression MINUS expression .) ]
  ! PLUS            [ shift and go to state 34 ]
  ! MINUS           [ shift and go to state 35 ]
  ! EQ              [ shift and go to state 38 ]
  ! NE              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GT              [ shift and go to state 41 ]
  ! LE              [ shift and go to state 42 ]
  ! GE              [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 59

    (45) expression -> expression MULTIPLY expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    PLUS            reduce using rule 45 (expression -> expression MULTIPLY expression .)
    MINUS           reduce using rule 45 (expression -> expression MULTIPLY expression .)
    MULTIPLY        reduce using rule 45 (expression -> expression MULTIPLY expression .)
    DIVIDE          reduce using rule 45 (expression -> expression MULTIPLY expression .)
    EQ              reduce using rule 45 (expression -> expression MULTIPLY expression .)
    NE              reduce using rule 45 (expression -> expression MULTIPLY expression .)
    LT              reduce using rule 45 (expression -> expression MULTIPLY expression .)
    GT              reduce using rule 45 (expression -> expression MULTIPLY expression .)
    LE              reduce using rule 45 (expression -> expression MULTIPLY expression .)
    GE              reduce using rule 45 (expression -> expression MULTIPLY expression .)
    AND             reduce using rule 45 (expression -> expression MULTIPLY expression .)
    OR              reduce using rule 45 (expression -> expression MULTIPLY expression .)
    SEMICOLON       reduce using rule 45 (expression -> expression MULTIPLY expression .)
    RPAREN          reduce using rule 45 (expression -> expression MULTIPLY expression .)
    COMMA           reduce using rule 45 (expression -> expression MULTIPLY expression .)

  ! PLUS            [ shift and go to state 34 ]
  ! MINUS           [ shift and go to state 35 ]
  ! MULTIPLY        [ shift and go to state 36 ]
  ! DIVIDE          [ shift and go to state 37 ]
  ! EQ              [ shift and go to state 38 ]
  ! NE              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GT              [ shift and go to state 41 ]
  ! LE              [ shift and go to state 42 ]
  ! GE              [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 60

    (46) expression -> expression DIVIDE expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    PLUS            reduce using rule 46 (expression -> expression DIVIDE expression .)
    MINUS           reduce using rule 46 (expression -> expression DIVIDE expression .)
    MULTIPLY        reduce using rule 46 (expression -> expression DIVIDE expression .)
    DIVIDE          reduce using rule 46 (expression -> expression DIVIDE expression .)
    EQ              reduce using rule 46 (expression -> expression DIVIDE expression .)
    NE              reduce using rule 46 (expression -> expression DIVIDE expression .)
    LT              reduce using rule 46 (expression -> expression DIVIDE expression .)
    GT              reduce using rule 46 (expression -> expression DIVIDE expression .)
    LE              reduce using rule 46 (expression -> expression DIVIDE expression .)
    GE              reduce using rule 46 (expression -> expression DIVIDE expression .)
    AND             reduce using rule 46 (expression -> expression DIVIDE expression .)
    OR              reduce using rule 46 (expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 46 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 46 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 46 (expression -> expression DIVIDE expression .)

  ! PLUS            [ shift and go to state 34 ]
  ! MINUS           [ shift and go to state 35 ]
  ! MULTIPLY        [ shift and go to state 36 ]
  ! DIVIDE          [ shift and go to state 37 ]
  ! EQ              [ shift and go to state 38 ]
  ! NE              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GT              [ shift and go to state 41 ]
  ! LE              [ shift and go to state 42 ]
  ! GE              [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 61

    (47) expression -> expression EQ expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    EQ              reduce using rule 47 (expression -> expression EQ expression .)
    NE              reduce using rule 47 (expression -> expression EQ expression .)
    AND             reduce using rule 47 (expression -> expression EQ expression .)
    OR              reduce using rule 47 (expression -> expression EQ expression .)
    SEMICOLON       reduce using rule 47 (expression -> expression EQ expression .)
    RPAREN          reduce using rule 47 (expression -> expression EQ expression .)
    COMMA           reduce using rule 47 (expression -> expression EQ expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    LT              shift and go to state 40
    GT              shift and go to state 41
    LE              shift and go to state 42
    GE              shift and go to state 43

  ! PLUS            [ reduce using rule 47 (expression -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 47 (expression -> expression EQ expression .) ]
  ! MULTIPLY        [ reduce using rule 47 (expression -> expression EQ expression .) ]
  ! DIVIDE          [ reduce using rule 47 (expression -> expression EQ expression .) ]
  ! LT              [ reduce using rule 47 (expression -> expression EQ expression .) ]
  ! GT              [ reduce using rule 47 (expression -> expression EQ expression .) ]
  ! LE              [ reduce using rule 47 (expression -> expression EQ expression .) ]
  ! GE              [ reduce using rule 47 (expression -> expression EQ expression .) ]
  ! EQ              [ shift and go to state 38 ]
  ! NE              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 62

    (48) expression -> expression NE expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    EQ              reduce using rule 48 (expression -> expression NE expression .)
    NE              reduce using rule 48 (expression -> expression NE expression .)
    AND             reduce using rule 48 (expression -> expression NE expression .)
    OR              reduce using rule 48 (expression -> expression NE expression .)
    SEMICOLON       reduce using rule 48 (expression -> expression NE expression .)
    RPAREN          reduce using rule 48 (expression -> expression NE expression .)
    COMMA           reduce using rule 48 (expression -> expression NE expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    LT              shift and go to state 40
    GT              shift and go to state 41
    LE              shift and go to state 42
    GE              shift and go to state 43

  ! PLUS            [ reduce using rule 48 (expression -> expression NE expression .) ]
  ! MINUS           [ reduce using rule 48 (expression -> expression NE expression .) ]
  ! MULTIPLY        [ reduce using rule 48 (expression -> expression NE expression .) ]
  ! DIVIDE          [ reduce using rule 48 (expression -> expression NE expression .) ]
  ! LT              [ reduce using rule 48 (expression -> expression NE expression .) ]
  ! GT              [ reduce using rule 48 (expression -> expression NE expression .) ]
  ! LE              [ reduce using rule 48 (expression -> expression NE expression .) ]
  ! GE              [ reduce using rule 48 (expression -> expression NE expression .) ]
  ! EQ              [ shift and go to state 38 ]
  ! NE              [ shift and go to state 39 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 63

    (49) expression -> expression LT expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    EQ              reduce using rule 49 (expression -> expression LT expression .)
    NE              reduce using rule 49 (expression -> expression LT expression .)
    LT              reduce using rule 49 (expression -> expression LT expression .)
    GT              reduce using rule 49 (expression -> expression LT expression .)
    LE              reduce using rule 49 (expression -> expression LT expression .)
    GE              reduce using rule 49 (expression -> expression LT expression .)
    AND             reduce using rule 49 (expression -> expression LT expression .)
    OR              reduce using rule 49 (expression -> expression LT expression .)
    SEMICOLON       reduce using rule 49 (expression -> expression LT expression .)
    RPAREN          reduce using rule 49 (expression -> expression LT expression .)
    COMMA           reduce using rule 49 (expression -> expression LT expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37

  ! PLUS            [ reduce using rule 49 (expression -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 49 (expression -> expression LT expression .) ]
  ! MULTIPLY        [ reduce using rule 49 (expression -> expression LT expression .) ]
  ! DIVIDE          [ reduce using rule 49 (expression -> expression LT expression .) ]
  ! EQ              [ shift and go to state 38 ]
  ! NE              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GT              [ shift and go to state 41 ]
  ! LE              [ shift and go to state 42 ]
  ! GE              [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 64

    (50) expression -> expression GT expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    EQ              reduce using rule 50 (expression -> expression GT expression .)
    NE              reduce using rule 50 (expression -> expression GT expression .)
    LT              reduce using rule 50 (expression -> expression GT expression .)
    GT              reduce using rule 50 (expression -> expression GT expression .)
    LE              reduce using rule 50 (expression -> expression GT expression .)
    GE              reduce using rule 50 (expression -> expression GT expression .)
    AND             reduce using rule 50 (expression -> expression GT expression .)
    OR              reduce using rule 50 (expression -> expression GT expression .)
    SEMICOLON       reduce using rule 50 (expression -> expression GT expression .)
    RPAREN          reduce using rule 50 (expression -> expression GT expression .)
    COMMA           reduce using rule 50 (expression -> expression GT expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37

  ! PLUS            [ reduce using rule 50 (expression -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 50 (expression -> expression GT expression .) ]
  ! MULTIPLY        [ reduce using rule 50 (expression -> expression GT expression .) ]
  ! DIVIDE          [ reduce using rule 50 (expression -> expression GT expression .) ]
  ! EQ              [ shift and go to state 38 ]
  ! NE              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GT              [ shift and go to state 41 ]
  ! LE              [ shift and go to state 42 ]
  ! GE              [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 65

    (51) expression -> expression LE expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    EQ              reduce using rule 51 (expression -> expression LE expression .)
    NE              reduce using rule 51 (expression -> expression LE expression .)
    LT              reduce using rule 51 (expression -> expression LE expression .)
    GT              reduce using rule 51 (expression -> expression LE expression .)
    LE              reduce using rule 51 (expression -> expression LE expression .)
    GE              reduce using rule 51 (expression -> expression LE expression .)
    AND             reduce using rule 51 (expression -> expression LE expression .)
    OR              reduce using rule 51 (expression -> expression LE expression .)
    SEMICOLON       reduce using rule 51 (expression -> expression LE expression .)
    RPAREN          reduce using rule 51 (expression -> expression LE expression .)
    COMMA           reduce using rule 51 (expression -> expression LE expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37

  ! PLUS            [ reduce using rule 51 (expression -> expression LE expression .) ]
  ! MINUS           [ reduce using rule 51 (expression -> expression LE expression .) ]
  ! MULTIPLY        [ reduce using rule 51 (expression -> expression LE expression .) ]
  ! DIVIDE          [ reduce using rule 51 (expression -> expression LE expression .) ]
  ! EQ              [ shift and go to state 38 ]
  ! NE              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GT              [ shift and go to state 41 ]
  ! LE              [ shift and go to state 42 ]
  ! GE              [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 66

    (52) expression -> expression GE expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    EQ              reduce using rule 52 (expression -> expression GE expression .)
    NE              reduce using rule 52 (expression -> expression GE expression .)
    LT              reduce using rule 52 (expression -> expression GE expression .)
    GT              reduce using rule 52 (expression -> expression GE expression .)
    LE              reduce using rule 52 (expression -> expression GE expression .)
    GE              reduce using rule 52 (expression -> expression GE expression .)
    AND             reduce using rule 52 (expression -> expression GE expression .)
    OR              reduce using rule 52 (expression -> expression GE expression .)
    SEMICOLON       reduce using rule 52 (expression -> expression GE expression .)
    RPAREN          reduce using rule 52 (expression -> expression GE expression .)
    COMMA           reduce using rule 52 (expression -> expression GE expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37

  ! PLUS            [ reduce using rule 52 (expression -> expression GE expression .) ]
  ! MINUS           [ reduce using rule 52 (expression -> expression GE expression .) ]
  ! MULTIPLY        [ reduce using rule 52 (expression -> expression GE expression .) ]
  ! DIVIDE          [ reduce using rule 52 (expression -> expression GE expression .) ]
  ! EQ              [ shift and go to state 38 ]
  ! NE              [ shift and go to state 39 ]
  ! LT              [ shift and go to state 40 ]
  ! GT              [ shift and go to state 41 ]
  ! LE              [ shift and go to state 42 ]
  ! GE              [ shift and go to state 43 ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 67

    (53) expression -> expression AND expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    AND             reduce using rule 53 (expression -> expression AND expression .)
    OR              reduce using rule 53 (expression -> expression AND expression .)
    SEMICOLON       reduce using rule 53 (expression -> expression AND expression .)
    RPAREN          reduce using rule 53 (expression -> expression AND expression .)
    COMMA           reduce using rule 53 (expression -> expression AND expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    EQ              shift and go to state 38
    NE              shift and go to state 39
    LT              shift and go to state 40
    GT              shift and go to state 41
    LE              shift and go to state 42
    GE              shift and go to state 43

  ! PLUS            [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! MULTIPLY        [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! NE              [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! LT              [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! GT              [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 53 (expression -> expression AND expression .) ]
  ! AND             [ shift and go to state 44 ]
  ! OR              [ shift and go to state 45 ]


state 68

    (54) expression -> expression OR expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    OR              reduce using rule 54 (expression -> expression OR expression .)
    SEMICOLON       reduce using rule 54 (expression -> expression OR expression .)
    RPAREN          reduce using rule 54 (expression -> expression OR expression .)
    COMMA           reduce using rule 54 (expression -> expression OR expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    EQ              shift and go to state 38
    NE              shift and go to state 39
    LT              shift and go to state 40
    GT              shift and go to state 41
    LE              shift and go to state 42
    GE              shift and go to state 43
    AND             shift and go to state 44

  ! PLUS            [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! MULTIPLY        [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! NE              [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! LT              [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! GT              [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 54 (expression -> expression OR expression .) ]
  ! OR              [ shift and go to state 45 ]


state 69

    (57) expression -> LPAREN expression RPAREN .

    PLUS            reduce using rule 57 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 57 (expression -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 57 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 57 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 57 (expression -> LPAREN expression RPAREN .)
    NE              reduce using rule 57 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 57 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 57 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 57 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 57 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 57 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 57 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 57 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 57 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 57 (expression -> LPAREN expression RPAREN .)


state 70

    (12) function_decl -> type IDENTIFIER LPAREN params RPAREN block .

    INT             reduce using rule 12 (function_decl -> type IDENTIFIER LPAREN params RPAREN block .)
    FLOAT           reduce using rule 12 (function_decl -> type IDENTIFIER LPAREN params RPAREN block .)
    CHAR_TYPE       reduce using rule 12 (function_decl -> type IDENTIFIER LPAREN params RPAREN block .)
    VOID            reduce using rule 12 (function_decl -> type IDENTIFIER LPAREN params RPAREN block .)
    $end            reduce using rule 12 (function_decl -> type IDENTIFIER LPAREN params RPAREN block .)


state 71

    (18) block -> LBRACE . statements RBRACE
    (19) statements -> . statements statement
    (20) statements -> . empty
    (71) empty -> .

    RBRACE          reduce using rule 71 (empty -> .)
    SEMICOLON       reduce using rule 71 (empty -> .)
    IF              reduce using rule 71 (empty -> .)
    WHILE           reduce using rule 71 (empty -> .)
    FOR             reduce using rule 71 (empty -> .)
    RETURN          reduce using rule 71 (empty -> .)
    LBRACE          reduce using rule 71 (empty -> .)
    NOT             reduce using rule 71 (empty -> .)
    MINUS           reduce using rule 71 (empty -> .)
    LPAREN          reduce using rule 71 (empty -> .)
    IDENTIFIER      reduce using rule 71 (empty -> .)
    INT             reduce using rule 71 (empty -> .)
    FLOAT           reduce using rule 71 (empty -> .)
    CHAR_TYPE       reduce using rule 71 (empty -> .)
    VOID            reduce using rule 71 (empty -> .)
    INTEGER         reduce using rule 71 (empty -> .)
    FLOAT_NUMBER    reduce using rule 71 (empty -> .)
    STRING          reduce using rule 71 (empty -> .)
    CHAR            reduce using rule 71 (empty -> .)

    statements                     shift and go to state 75
    empty                          shift and go to state 76

state 72

    (15) param_list -> param_list COMMA param .

    COMMA           reduce using rule 15 (param_list -> param_list COMMA param .)
    RPAREN          reduce using rule 15 (param_list -> param_list COMMA param .)


state 73

    (66) function_call -> IDENTIFIER LPAREN args RPAREN .

    PLUS            reduce using rule 66 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    MINUS           reduce using rule 66 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    MULTIPLY        reduce using rule 66 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    DIVIDE          reduce using rule 66 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    EQ              reduce using rule 66 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    NE              reduce using rule 66 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    LT              reduce using rule 66 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    GT              reduce using rule 66 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    LE              reduce using rule 66 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    GE              reduce using rule 66 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    AND             reduce using rule 66 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    OR              reduce using rule 66 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    SEMICOLON       reduce using rule 66 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    RPAREN          reduce using rule 66 (function_call -> IDENTIFIER LPAREN args RPAREN .)
    COMMA           reduce using rule 66 (function_call -> IDENTIFIER LPAREN args RPAREN .)


state 74

    (69) arg_list -> arg_list COMMA . expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 77
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 75

    (18) block -> LBRACE statements . RBRACE
    (19) statements -> statements . statement
    (21) statement -> . expression_statement
    (22) statement -> . var_decl SEMICOLON
    (23) statement -> . if_statement
    (24) statement -> . while_statement
    (25) statement -> . for_statement
    (26) statement -> . return_statement
    (27) statement -> . block
    (28) expression_statement -> . expression SEMICOLON
    (29) expression_statement -> . SEMICOLON
    (6) var_decl -> . type IDENTIFIER
    (7) var_decl -> . type IDENTIFIER ASSIGN expression
    (30) if_statement -> . IF LPAREN expression RPAREN statement
    (31) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (32) while_statement -> . WHILE LPAREN expression RPAREN statement
    (33) for_statement -> . FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement
    (41) return_statement -> . RETURN expression SEMICOLON
    (42) return_statement -> . RETURN SEMICOLON
    (18) block -> . LBRACE statements RBRACE
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . CHAR_TYPE
    (11) type -> . VOID
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    RBRACE          shift and go to state 78
    SEMICOLON       shift and go to state 82
    IF              shift and go to state 90
    WHILE           shift and go to state 91
    FOR             shift and go to state 92
    RETURN          shift and go to state 93
    LBRACE          shift and go to state 71
    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR_TYPE       shift and go to state 9
    VOID            shift and go to state 10
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    statement                      shift and go to state 79
    expression_statement           shift and go to state 80
    var_decl                       shift and go to state 81
    if_statement                   shift and go to state 83
    while_statement                shift and go to state 84
    for_statement                  shift and go to state 85
    return_statement               shift and go to state 86
    block                          shift and go to state 87
    expression                     shift and go to state 88
    type                           shift and go to state 89
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 76

    (20) statements -> empty .

    RBRACE          reduce using rule 20 (statements -> empty .)
    SEMICOLON       reduce using rule 20 (statements -> empty .)
    IF              reduce using rule 20 (statements -> empty .)
    WHILE           reduce using rule 20 (statements -> empty .)
    FOR             reduce using rule 20 (statements -> empty .)
    RETURN          reduce using rule 20 (statements -> empty .)
    LBRACE          reduce using rule 20 (statements -> empty .)
    NOT             reduce using rule 20 (statements -> empty .)
    MINUS           reduce using rule 20 (statements -> empty .)
    LPAREN          reduce using rule 20 (statements -> empty .)
    IDENTIFIER      reduce using rule 20 (statements -> empty .)
    INT             reduce using rule 20 (statements -> empty .)
    FLOAT           reduce using rule 20 (statements -> empty .)
    CHAR_TYPE       reduce using rule 20 (statements -> empty .)
    VOID            reduce using rule 20 (statements -> empty .)
    INTEGER         reduce using rule 20 (statements -> empty .)
    FLOAT_NUMBER    reduce using rule 20 (statements -> empty .)
    STRING          reduce using rule 20 (statements -> empty .)
    CHAR            reduce using rule 20 (statements -> empty .)


state 77

    (69) arg_list -> arg_list COMMA expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    COMMA           reduce using rule 69 (arg_list -> arg_list COMMA expression .)
    RPAREN          reduce using rule 69 (arg_list -> arg_list COMMA expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    EQ              shift and go to state 38
    NE              shift and go to state 39
    LT              shift and go to state 40
    GT              shift and go to state 41
    LE              shift and go to state 42
    GE              shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 78

    (18) block -> LBRACE statements RBRACE .

    INT             reduce using rule 18 (block -> LBRACE statements RBRACE .)
    FLOAT           reduce using rule 18 (block -> LBRACE statements RBRACE .)
    CHAR_TYPE       reduce using rule 18 (block -> LBRACE statements RBRACE .)
    VOID            reduce using rule 18 (block -> LBRACE statements RBRACE .)
    $end            reduce using rule 18 (block -> LBRACE statements RBRACE .)
    RBRACE          reduce using rule 18 (block -> LBRACE statements RBRACE .)
    SEMICOLON       reduce using rule 18 (block -> LBRACE statements RBRACE .)
    IF              reduce using rule 18 (block -> LBRACE statements RBRACE .)
    WHILE           reduce using rule 18 (block -> LBRACE statements RBRACE .)
    FOR             reduce using rule 18 (block -> LBRACE statements RBRACE .)
    RETURN          reduce using rule 18 (block -> LBRACE statements RBRACE .)
    LBRACE          reduce using rule 18 (block -> LBRACE statements RBRACE .)
    NOT             reduce using rule 18 (block -> LBRACE statements RBRACE .)
    MINUS           reduce using rule 18 (block -> LBRACE statements RBRACE .)
    LPAREN          reduce using rule 18 (block -> LBRACE statements RBRACE .)
    IDENTIFIER      reduce using rule 18 (block -> LBRACE statements RBRACE .)
    INTEGER         reduce using rule 18 (block -> LBRACE statements RBRACE .)
    FLOAT_NUMBER    reduce using rule 18 (block -> LBRACE statements RBRACE .)
    STRING          reduce using rule 18 (block -> LBRACE statements RBRACE .)
    CHAR            reduce using rule 18 (block -> LBRACE statements RBRACE .)
    ELSE            reduce using rule 18 (block -> LBRACE statements RBRACE .)


state 79

    (19) statements -> statements statement .

    RBRACE          reduce using rule 19 (statements -> statements statement .)
    SEMICOLON       reduce using rule 19 (statements -> statements statement .)
    IF              reduce using rule 19 (statements -> statements statement .)
    WHILE           reduce using rule 19 (statements -> statements statement .)
    FOR             reduce using rule 19 (statements -> statements statement .)
    RETURN          reduce using rule 19 (statements -> statements statement .)
    LBRACE          reduce using rule 19 (statements -> statements statement .)
    NOT             reduce using rule 19 (statements -> statements statement .)
    MINUS           reduce using rule 19 (statements -> statements statement .)
    LPAREN          reduce using rule 19 (statements -> statements statement .)
    IDENTIFIER      reduce using rule 19 (statements -> statements statement .)
    INT             reduce using rule 19 (statements -> statements statement .)
    FLOAT           reduce using rule 19 (statements -> statements statement .)
    CHAR_TYPE       reduce using rule 19 (statements -> statements statement .)
    VOID            reduce using rule 19 (statements -> statements statement .)
    INTEGER         reduce using rule 19 (statements -> statements statement .)
    FLOAT_NUMBER    reduce using rule 19 (statements -> statements statement .)
    STRING          reduce using rule 19 (statements -> statements statement .)
    CHAR            reduce using rule 19 (statements -> statements statement .)


state 80

    (21) statement -> expression_statement .

    RBRACE          reduce using rule 21 (statement -> expression_statement .)
    SEMICOLON       reduce using rule 21 (statement -> expression_statement .)
    IF              reduce using rule 21 (statement -> expression_statement .)
    WHILE           reduce using rule 21 (statement -> expression_statement .)
    FOR             reduce using rule 21 (statement -> expression_statement .)
    RETURN          reduce using rule 21 (statement -> expression_statement .)
    LBRACE          reduce using rule 21 (statement -> expression_statement .)
    NOT             reduce using rule 21 (statement -> expression_statement .)
    MINUS           reduce using rule 21 (statement -> expression_statement .)
    LPAREN          reduce using rule 21 (statement -> expression_statement .)
    IDENTIFIER      reduce using rule 21 (statement -> expression_statement .)
    INT             reduce using rule 21 (statement -> expression_statement .)
    FLOAT           reduce using rule 21 (statement -> expression_statement .)
    CHAR_TYPE       reduce using rule 21 (statement -> expression_statement .)
    VOID            reduce using rule 21 (statement -> expression_statement .)
    INTEGER         reduce using rule 21 (statement -> expression_statement .)
    FLOAT_NUMBER    reduce using rule 21 (statement -> expression_statement .)
    STRING          reduce using rule 21 (statement -> expression_statement .)
    CHAR            reduce using rule 21 (statement -> expression_statement .)
    ELSE            reduce using rule 21 (statement -> expression_statement .)


state 81

    (22) statement -> var_decl . SEMICOLON

    SEMICOLON       shift and go to state 94


state 82

    (29) expression_statement -> SEMICOLON .

    RBRACE          reduce using rule 29 (expression_statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 29 (expression_statement -> SEMICOLON .)
    IF              reduce using rule 29 (expression_statement -> SEMICOLON .)
    WHILE           reduce using rule 29 (expression_statement -> SEMICOLON .)
    FOR             reduce using rule 29 (expression_statement -> SEMICOLON .)
    RETURN          reduce using rule 29 (expression_statement -> SEMICOLON .)
    LBRACE          reduce using rule 29 (expression_statement -> SEMICOLON .)
    NOT             reduce using rule 29 (expression_statement -> SEMICOLON .)
    MINUS           reduce using rule 29 (expression_statement -> SEMICOLON .)
    LPAREN          reduce using rule 29 (expression_statement -> SEMICOLON .)
    IDENTIFIER      reduce using rule 29 (expression_statement -> SEMICOLON .)
    INT             reduce using rule 29 (expression_statement -> SEMICOLON .)
    FLOAT           reduce using rule 29 (expression_statement -> SEMICOLON .)
    CHAR_TYPE       reduce using rule 29 (expression_statement -> SEMICOLON .)
    VOID            reduce using rule 29 (expression_statement -> SEMICOLON .)
    INTEGER         reduce using rule 29 (expression_statement -> SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 29 (expression_statement -> SEMICOLON .)
    STRING          reduce using rule 29 (expression_statement -> SEMICOLON .)
    CHAR            reduce using rule 29 (expression_statement -> SEMICOLON .)
    ELSE            reduce using rule 29 (expression_statement -> SEMICOLON .)


state 83

    (23) statement -> if_statement .

    RBRACE          reduce using rule 23 (statement -> if_statement .)
    SEMICOLON       reduce using rule 23 (statement -> if_statement .)
    IF              reduce using rule 23 (statement -> if_statement .)
    WHILE           reduce using rule 23 (statement -> if_statement .)
    FOR             reduce using rule 23 (statement -> if_statement .)
    RETURN          reduce using rule 23 (statement -> if_statement .)
    LBRACE          reduce using rule 23 (statement -> if_statement .)
    NOT             reduce using rule 23 (statement -> if_statement .)
    MINUS           reduce using rule 23 (statement -> if_statement .)
    LPAREN          reduce using rule 23 (statement -> if_statement .)
    IDENTIFIER      reduce using rule 23 (statement -> if_statement .)
    INT             reduce using rule 23 (statement -> if_statement .)
    FLOAT           reduce using rule 23 (statement -> if_statement .)
    CHAR_TYPE       reduce using rule 23 (statement -> if_statement .)
    VOID            reduce using rule 23 (statement -> if_statement .)
    INTEGER         reduce using rule 23 (statement -> if_statement .)
    FLOAT_NUMBER    reduce using rule 23 (statement -> if_statement .)
    STRING          reduce using rule 23 (statement -> if_statement .)
    CHAR            reduce using rule 23 (statement -> if_statement .)
    ELSE            reduce using rule 23 (statement -> if_statement .)


state 84

    (24) statement -> while_statement .

    RBRACE          reduce using rule 24 (statement -> while_statement .)
    SEMICOLON       reduce using rule 24 (statement -> while_statement .)
    IF              reduce using rule 24 (statement -> while_statement .)
    WHILE           reduce using rule 24 (statement -> while_statement .)
    FOR             reduce using rule 24 (statement -> while_statement .)
    RETURN          reduce using rule 24 (statement -> while_statement .)
    LBRACE          reduce using rule 24 (statement -> while_statement .)
    NOT             reduce using rule 24 (statement -> while_statement .)
    MINUS           reduce using rule 24 (statement -> while_statement .)
    LPAREN          reduce using rule 24 (statement -> while_statement .)
    IDENTIFIER      reduce using rule 24 (statement -> while_statement .)
    INT             reduce using rule 24 (statement -> while_statement .)
    FLOAT           reduce using rule 24 (statement -> while_statement .)
    CHAR_TYPE       reduce using rule 24 (statement -> while_statement .)
    VOID            reduce using rule 24 (statement -> while_statement .)
    INTEGER         reduce using rule 24 (statement -> while_statement .)
    FLOAT_NUMBER    reduce using rule 24 (statement -> while_statement .)
    STRING          reduce using rule 24 (statement -> while_statement .)
    CHAR            reduce using rule 24 (statement -> while_statement .)
    ELSE            reduce using rule 24 (statement -> while_statement .)


state 85

    (25) statement -> for_statement .

    RBRACE          reduce using rule 25 (statement -> for_statement .)
    SEMICOLON       reduce using rule 25 (statement -> for_statement .)
    IF              reduce using rule 25 (statement -> for_statement .)
    WHILE           reduce using rule 25 (statement -> for_statement .)
    FOR             reduce using rule 25 (statement -> for_statement .)
    RETURN          reduce using rule 25 (statement -> for_statement .)
    LBRACE          reduce using rule 25 (statement -> for_statement .)
    NOT             reduce using rule 25 (statement -> for_statement .)
    MINUS           reduce using rule 25 (statement -> for_statement .)
    LPAREN          reduce using rule 25 (statement -> for_statement .)
    IDENTIFIER      reduce using rule 25 (statement -> for_statement .)
    INT             reduce using rule 25 (statement -> for_statement .)
    FLOAT           reduce using rule 25 (statement -> for_statement .)
    CHAR_TYPE       reduce using rule 25 (statement -> for_statement .)
    VOID            reduce using rule 25 (statement -> for_statement .)
    INTEGER         reduce using rule 25 (statement -> for_statement .)
    FLOAT_NUMBER    reduce using rule 25 (statement -> for_statement .)
    STRING          reduce using rule 25 (statement -> for_statement .)
    CHAR            reduce using rule 25 (statement -> for_statement .)
    ELSE            reduce using rule 25 (statement -> for_statement .)


state 86

    (26) statement -> return_statement .

    RBRACE          reduce using rule 26 (statement -> return_statement .)
    SEMICOLON       reduce using rule 26 (statement -> return_statement .)
    IF              reduce using rule 26 (statement -> return_statement .)
    WHILE           reduce using rule 26 (statement -> return_statement .)
    FOR             reduce using rule 26 (statement -> return_statement .)
    RETURN          reduce using rule 26 (statement -> return_statement .)
    LBRACE          reduce using rule 26 (statement -> return_statement .)
    NOT             reduce using rule 26 (statement -> return_statement .)
    MINUS           reduce using rule 26 (statement -> return_statement .)
    LPAREN          reduce using rule 26 (statement -> return_statement .)
    IDENTIFIER      reduce using rule 26 (statement -> return_statement .)
    INT             reduce using rule 26 (statement -> return_statement .)
    FLOAT           reduce using rule 26 (statement -> return_statement .)
    CHAR_TYPE       reduce using rule 26 (statement -> return_statement .)
    VOID            reduce using rule 26 (statement -> return_statement .)
    INTEGER         reduce using rule 26 (statement -> return_statement .)
    FLOAT_NUMBER    reduce using rule 26 (statement -> return_statement .)
    STRING          reduce using rule 26 (statement -> return_statement .)
    CHAR            reduce using rule 26 (statement -> return_statement .)
    ELSE            reduce using rule 26 (statement -> return_statement .)


state 87

    (27) statement -> block .

    RBRACE          reduce using rule 27 (statement -> block .)
    SEMICOLON       reduce using rule 27 (statement -> block .)
    IF              reduce using rule 27 (statement -> block .)
    WHILE           reduce using rule 27 (statement -> block .)
    FOR             reduce using rule 27 (statement -> block .)
    RETURN          reduce using rule 27 (statement -> block .)
    LBRACE          reduce using rule 27 (statement -> block .)
    NOT             reduce using rule 27 (statement -> block .)
    MINUS           reduce using rule 27 (statement -> block .)
    LPAREN          reduce using rule 27 (statement -> block .)
    IDENTIFIER      reduce using rule 27 (statement -> block .)
    INT             reduce using rule 27 (statement -> block .)
    FLOAT           reduce using rule 27 (statement -> block .)
    CHAR_TYPE       reduce using rule 27 (statement -> block .)
    VOID            reduce using rule 27 (statement -> block .)
    INTEGER         reduce using rule 27 (statement -> block .)
    FLOAT_NUMBER    reduce using rule 27 (statement -> block .)
    STRING          reduce using rule 27 (statement -> block .)
    CHAR            reduce using rule 27 (statement -> block .)
    ELSE            reduce using rule 27 (statement -> block .)


state 88

    (28) expression_statement -> expression . SEMICOLON
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    SEMICOLON       shift and go to state 95
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    EQ              shift and go to state 38
    NE              shift and go to state 39
    LT              shift and go to state 40
    GT              shift and go to state 41
    LE              shift and go to state 42
    GE              shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 89

    (6) var_decl -> type . IDENTIFIER
    (7) var_decl -> type . IDENTIFIER ASSIGN expression

    IDENTIFIER      shift and go to state 96


state 90

    (30) if_statement -> IF . LPAREN expression RPAREN statement
    (31) if_statement -> IF . LPAREN expression RPAREN statement ELSE statement

    LPAREN          shift and go to state 97


state 91

    (32) while_statement -> WHILE . LPAREN expression RPAREN statement

    LPAREN          shift and go to state 98


state 92

    (33) for_statement -> FOR . LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement

    LPAREN          shift and go to state 99


state 93

    (41) return_statement -> RETURN . expression SEMICOLON
    (42) return_statement -> RETURN . SEMICOLON
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    SEMICOLON       shift and go to state 101
    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 100
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 94

    (22) statement -> var_decl SEMICOLON .

    RBRACE          reduce using rule 22 (statement -> var_decl SEMICOLON .)
    SEMICOLON       reduce using rule 22 (statement -> var_decl SEMICOLON .)
    IF              reduce using rule 22 (statement -> var_decl SEMICOLON .)
    WHILE           reduce using rule 22 (statement -> var_decl SEMICOLON .)
    FOR             reduce using rule 22 (statement -> var_decl SEMICOLON .)
    RETURN          reduce using rule 22 (statement -> var_decl SEMICOLON .)
    LBRACE          reduce using rule 22 (statement -> var_decl SEMICOLON .)
    NOT             reduce using rule 22 (statement -> var_decl SEMICOLON .)
    MINUS           reduce using rule 22 (statement -> var_decl SEMICOLON .)
    LPAREN          reduce using rule 22 (statement -> var_decl SEMICOLON .)
    IDENTIFIER      reduce using rule 22 (statement -> var_decl SEMICOLON .)
    INT             reduce using rule 22 (statement -> var_decl SEMICOLON .)
    FLOAT           reduce using rule 22 (statement -> var_decl SEMICOLON .)
    CHAR_TYPE       reduce using rule 22 (statement -> var_decl SEMICOLON .)
    VOID            reduce using rule 22 (statement -> var_decl SEMICOLON .)
    INTEGER         reduce using rule 22 (statement -> var_decl SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 22 (statement -> var_decl SEMICOLON .)
    STRING          reduce using rule 22 (statement -> var_decl SEMICOLON .)
    CHAR            reduce using rule 22 (statement -> var_decl SEMICOLON .)
    ELSE            reduce using rule 22 (statement -> var_decl SEMICOLON .)


state 95

    (28) expression_statement -> expression SEMICOLON .

    RBRACE          reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    SEMICOLON       reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    IF              reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    WHILE           reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    FOR             reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    RETURN          reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    LBRACE          reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    NOT             reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    MINUS           reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    LPAREN          reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    IDENTIFIER      reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    INT             reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    FLOAT           reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    CHAR_TYPE       reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    VOID            reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    INTEGER         reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    STRING          reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    CHAR            reduce using rule 28 (expression_statement -> expression SEMICOLON .)
    ELSE            reduce using rule 28 (expression_statement -> expression SEMICOLON .)


state 96

    (6) var_decl -> type IDENTIFIER .
    (7) var_decl -> type IDENTIFIER . ASSIGN expression

    SEMICOLON       reduce using rule 6 (var_decl -> type IDENTIFIER .)
    ASSIGN          shift and go to state 14


state 97

    (30) if_statement -> IF LPAREN . expression RPAREN statement
    (31) if_statement -> IF LPAREN . expression RPAREN statement ELSE statement
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 102
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 98

    (32) while_statement -> WHILE LPAREN . expression RPAREN statement
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 103
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 99

    (33) for_statement -> FOR LPAREN . for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement
    (34) for_init -> . var_decl
    (35) for_init -> . expression
    (36) for_init -> . empty
    (6) var_decl -> . type IDENTIFIER
    (7) var_decl -> . type IDENTIFIER ASSIGN expression
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (71) empty -> .
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . CHAR_TYPE
    (11) type -> . VOID
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       reduce using rule 71 (empty -> .)
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR_TYPE       shift and go to state 9
    VOID            shift and go to state 10
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    for_init                       shift and go to state 104
    var_decl                       shift and go to state 105
    expression                     shift and go to state 106
    empty                          shift and go to state 107
    type                           shift and go to state 89
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 100

    (41) return_statement -> RETURN expression . SEMICOLON
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    SEMICOLON       shift and go to state 108
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    EQ              shift and go to state 38
    NE              shift and go to state 39
    LT              shift and go to state 40
    GT              shift and go to state 41
    LE              shift and go to state 42
    GE              shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 101

    (42) return_statement -> RETURN SEMICOLON .

    RBRACE          reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    IF              reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    WHILE           reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    FOR             reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    RETURN          reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    NOT             reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    MINUS           reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    IDENTIFIER      reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    INT             reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    CHAR_TYPE       reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    VOID            reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    INTEGER         reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    STRING          reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    CHAR            reduce using rule 42 (return_statement -> RETURN SEMICOLON .)
    ELSE            reduce using rule 42 (return_statement -> RETURN SEMICOLON .)


state 102

    (30) if_statement -> IF LPAREN expression . RPAREN statement
    (31) if_statement -> IF LPAREN expression . RPAREN statement ELSE statement
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    RPAREN          shift and go to state 109
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    EQ              shift and go to state 38
    NE              shift and go to state 39
    LT              shift and go to state 40
    GT              shift and go to state 41
    LE              shift and go to state 42
    GE              shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 103

    (32) while_statement -> WHILE LPAREN expression . RPAREN statement
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    RPAREN          shift and go to state 110
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    EQ              shift and go to state 38
    NE              shift and go to state 39
    LT              shift and go to state 40
    GT              shift and go to state 41
    LE              shift and go to state 42
    GE              shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 104

    (33) for_statement -> FOR LPAREN for_init . SEMICOLON for_cond SEMICOLON for_update RPAREN statement

    SEMICOLON       shift and go to state 111


state 105

    (34) for_init -> var_decl .

    SEMICOLON       reduce using rule 34 (for_init -> var_decl .)


state 106

    (35) for_init -> expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    SEMICOLON       reduce using rule 35 (for_init -> expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    EQ              shift and go to state 38
    NE              shift and go to state 39
    LT              shift and go to state 40
    GT              shift and go to state 41
    LE              shift and go to state 42
    GE              shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 107

    (36) for_init -> empty .

    SEMICOLON       reduce using rule 36 (for_init -> empty .)


state 108

    (41) return_statement -> RETURN expression SEMICOLON .

    RBRACE          reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    SEMICOLON       reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    IF              reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    LBRACE          reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    NOT             reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    MINUS           reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    LPAREN          reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    INT             reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    FLOAT           reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    CHAR_TYPE       reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    VOID            reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    INTEGER         reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    FLOAT_NUMBER    reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    CHAR            reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 41 (return_statement -> RETURN expression SEMICOLON .)


state 109

    (30) if_statement -> IF LPAREN expression RPAREN . statement
    (31) if_statement -> IF LPAREN expression RPAREN . statement ELSE statement
    (21) statement -> . expression_statement
    (22) statement -> . var_decl SEMICOLON
    (23) statement -> . if_statement
    (24) statement -> . while_statement
    (25) statement -> . for_statement
    (26) statement -> . return_statement
    (27) statement -> . block
    (28) expression_statement -> . expression SEMICOLON
    (29) expression_statement -> . SEMICOLON
    (6) var_decl -> . type IDENTIFIER
    (7) var_decl -> . type IDENTIFIER ASSIGN expression
    (30) if_statement -> . IF LPAREN expression RPAREN statement
    (31) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (32) while_statement -> . WHILE LPAREN expression RPAREN statement
    (33) for_statement -> . FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement
    (41) return_statement -> . RETURN expression SEMICOLON
    (42) return_statement -> . RETURN SEMICOLON
    (18) block -> . LBRACE statements RBRACE
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . CHAR_TYPE
    (11) type -> . VOID
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    SEMICOLON       shift and go to state 82
    IF              shift and go to state 90
    WHILE           shift and go to state 91
    FOR             shift and go to state 92
    RETURN          shift and go to state 93
    LBRACE          shift and go to state 71
    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR_TYPE       shift and go to state 9
    VOID            shift and go to state 10
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 88
    statement                      shift and go to state 112
    expression_statement           shift and go to state 80
    var_decl                       shift and go to state 81
    if_statement                   shift and go to state 83
    while_statement                shift and go to state 84
    for_statement                  shift and go to state 85
    return_statement               shift and go to state 86
    block                          shift and go to state 87
    type                           shift and go to state 89
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 110

    (32) while_statement -> WHILE LPAREN expression RPAREN . statement
    (21) statement -> . expression_statement
    (22) statement -> . var_decl SEMICOLON
    (23) statement -> . if_statement
    (24) statement -> . while_statement
    (25) statement -> . for_statement
    (26) statement -> . return_statement
    (27) statement -> . block
    (28) expression_statement -> . expression SEMICOLON
    (29) expression_statement -> . SEMICOLON
    (6) var_decl -> . type IDENTIFIER
    (7) var_decl -> . type IDENTIFIER ASSIGN expression
    (30) if_statement -> . IF LPAREN expression RPAREN statement
    (31) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (32) while_statement -> . WHILE LPAREN expression RPAREN statement
    (33) for_statement -> . FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement
    (41) return_statement -> . RETURN expression SEMICOLON
    (42) return_statement -> . RETURN SEMICOLON
    (18) block -> . LBRACE statements RBRACE
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . CHAR_TYPE
    (11) type -> . VOID
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    SEMICOLON       shift and go to state 82
    IF              shift and go to state 90
    WHILE           shift and go to state 91
    FOR             shift and go to state 92
    RETURN          shift and go to state 93
    LBRACE          shift and go to state 71
    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR_TYPE       shift and go to state 9
    VOID            shift and go to state 10
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 88
    statement                      shift and go to state 113
    expression_statement           shift and go to state 80
    var_decl                       shift and go to state 81
    if_statement                   shift and go to state 83
    while_statement                shift and go to state 84
    for_statement                  shift and go to state 85
    return_statement               shift and go to state 86
    block                          shift and go to state 87
    type                           shift and go to state 89
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 111

    (33) for_statement -> FOR LPAREN for_init SEMICOLON . for_cond SEMICOLON for_update RPAREN statement
    (37) for_cond -> . expression
    (38) for_cond -> . empty
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (71) empty -> .
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    SEMICOLON       reduce using rule 71 (empty -> .)
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    for_cond                       shift and go to state 114
    expression                     shift and go to state 115
    empty                          shift and go to state 116
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 112

    (30) if_statement -> IF LPAREN expression RPAREN statement .
    (31) if_statement -> IF LPAREN expression RPAREN statement . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    RBRACE          reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    SEMICOLON       reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    IF              reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    WHILE           reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    FOR             reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    RETURN          reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    LBRACE          reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    NOT             reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    MINUS           reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    LPAREN          reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    IDENTIFIER      reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    INT             reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    FLOAT           reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    CHAR_TYPE       reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    VOID            reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    INTEGER         reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    FLOAT_NUMBER    reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    STRING          reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    CHAR            reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .)
    ELSE            shift and go to state 117

  ! ELSE            [ reduce using rule 30 (if_statement -> IF LPAREN expression RPAREN statement .) ]


state 113

    (32) while_statement -> WHILE LPAREN expression RPAREN statement .

    RBRACE          reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    SEMICOLON       reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    IF              reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    WHILE           reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    FOR             reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    RETURN          reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    LBRACE          reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    NOT             reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    MINUS           reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    LPAREN          reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    IDENTIFIER      reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    INT             reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    FLOAT           reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    CHAR_TYPE       reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    VOID            reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    INTEGER         reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    FLOAT_NUMBER    reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    STRING          reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    CHAR            reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    ELSE            reduce using rule 32 (while_statement -> WHILE LPAREN expression RPAREN statement .)


state 114

    (33) for_statement -> FOR LPAREN for_init SEMICOLON for_cond . SEMICOLON for_update RPAREN statement

    SEMICOLON       shift and go to state 118


state 115

    (37) for_cond -> expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    SEMICOLON       reduce using rule 37 (for_cond -> expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    EQ              shift and go to state 38
    NE              shift and go to state 39
    LT              shift and go to state 40
    GT              shift and go to state 41
    LE              shift and go to state 42
    GE              shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 116

    (38) for_cond -> empty .

    SEMICOLON       reduce using rule 38 (for_cond -> empty .)


state 117

    (31) if_statement -> IF LPAREN expression RPAREN statement ELSE . statement
    (21) statement -> . expression_statement
    (22) statement -> . var_decl SEMICOLON
    (23) statement -> . if_statement
    (24) statement -> . while_statement
    (25) statement -> . for_statement
    (26) statement -> . return_statement
    (27) statement -> . block
    (28) expression_statement -> . expression SEMICOLON
    (29) expression_statement -> . SEMICOLON
    (6) var_decl -> . type IDENTIFIER
    (7) var_decl -> . type IDENTIFIER ASSIGN expression
    (30) if_statement -> . IF LPAREN expression RPAREN statement
    (31) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (32) while_statement -> . WHILE LPAREN expression RPAREN statement
    (33) for_statement -> . FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement
    (41) return_statement -> . RETURN expression SEMICOLON
    (42) return_statement -> . RETURN SEMICOLON
    (18) block -> . LBRACE statements RBRACE
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . CHAR_TYPE
    (11) type -> . VOID
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    SEMICOLON       shift and go to state 82
    IF              shift and go to state 90
    WHILE           shift and go to state 91
    FOR             shift and go to state 92
    RETURN          shift and go to state 93
    LBRACE          shift and go to state 71
    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR_TYPE       shift and go to state 9
    VOID            shift and go to state 10
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    expression                     shift and go to state 88
    statement                      shift and go to state 119
    expression_statement           shift and go to state 80
    var_decl                       shift and go to state 81
    if_statement                   shift and go to state 83
    while_statement                shift and go to state 84
    for_statement                  shift and go to state 85
    return_statement               shift and go to state 86
    block                          shift and go to state 87
    type                           shift and go to state 89
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 118

    (33) for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON . for_update RPAREN statement
    (39) for_update -> . expression
    (40) for_update -> . empty
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (71) empty -> .
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    RPAREN          reduce using rule 71 (empty -> .)
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    for_update                     shift and go to state 120
    expression                     shift and go to state 121
    empty                          shift and go to state 122
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 119

    (31) if_statement -> IF LPAREN expression RPAREN statement ELSE statement .

    RBRACE          reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    SEMICOLON       reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    IF              reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    WHILE           reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FOR             reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    RETURN          reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    LBRACE          reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    NOT             reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    MINUS           reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    LPAREN          reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    IDENTIFIER      reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    INT             reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FLOAT           reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    CHAR_TYPE       reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    VOID            reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    INTEGER         reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FLOAT_NUMBER    reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    STRING          reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    CHAR            reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    ELSE            reduce using rule 31 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)


state 120

    (33) for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update . RPAREN statement

    RPAREN          shift and go to state 123


state 121

    (39) for_update -> expression .
    (43) expression -> expression . PLUS expression
    (44) expression -> expression . MINUS expression
    (45) expression -> expression . MULTIPLY expression
    (46) expression -> expression . DIVIDE expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (53) expression -> expression . AND expression
    (54) expression -> expression . OR expression

    RPAREN          reduce using rule 39 (for_update -> expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    MULTIPLY        shift and go to state 36
    DIVIDE          shift and go to state 37
    EQ              shift and go to state 38
    NE              shift and go to state 39
    LT              shift and go to state 40
    GT              shift and go to state 41
    LE              shift and go to state 42
    GE              shift and go to state 43
    AND             shift and go to state 44
    OR              shift and go to state 45


state 122

    (40) for_update -> empty .

    RPAREN          reduce using rule 40 (for_update -> empty .)


state 123

    (33) for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN . statement
    (21) statement -> . expression_statement
    (22) statement -> . var_decl SEMICOLON
    (23) statement -> . if_statement
    (24) statement -> . while_statement
    (25) statement -> . for_statement
    (26) statement -> . return_statement
    (27) statement -> . block
    (28) expression_statement -> . expression SEMICOLON
    (29) expression_statement -> . SEMICOLON
    (6) var_decl -> . type IDENTIFIER
    (7) var_decl -> . type IDENTIFIER ASSIGN expression
    (30) if_statement -> . IF LPAREN expression RPAREN statement
    (31) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (32) while_statement -> . WHILE LPAREN expression RPAREN statement
    (33) for_statement -> . FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement
    (41) return_statement -> . RETURN expression SEMICOLON
    (42) return_statement -> . RETURN SEMICOLON
    (18) block -> . LBRACE statements RBRACE
    (43) expression -> . expression PLUS expression
    (44) expression -> . expression MINUS expression
    (45) expression -> . expression MULTIPLY expression
    (46) expression -> . expression DIVIDE expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) expression -> . expression AND expression
    (54) expression -> . expression OR expression
    (55) expression -> . NOT expression
    (56) expression -> . MINUS expression
    (57) expression -> . LPAREN expression RPAREN
    (58) expression -> . IDENTIFIER ASSIGN expression
    (59) expression -> . primary
    (8) type -> . INT
    (9) type -> . FLOAT
    (10) type -> . CHAR_TYPE
    (11) type -> . VOID
    (60) primary -> . INTEGER
    (61) primary -> . FLOAT_NUMBER
    (62) primary -> . STRING
    (63) primary -> . CHAR
    (64) primary -> . IDENTIFIER
    (65) primary -> . function_call
    (66) function_call -> . IDENTIFIER LPAREN args RPAREN

    SEMICOLON       shift and go to state 82
    IF              shift and go to state 90
    WHILE           shift and go to state 91
    FOR             shift and go to state 92
    RETURN          shift and go to state 93
    LBRACE          shift and go to state 71
    NOT             shift and go to state 19
    MINUS           shift and go to state 18
    LPAREN          shift and go to state 20
    IDENTIFIER      shift and go to state 16
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    CHAR_TYPE       shift and go to state 9
    VOID            shift and go to state 10
    INTEGER         shift and go to state 22
    FLOAT_NUMBER    shift and go to state 23
    STRING          shift and go to state 24
    CHAR            shift and go to state 25

    statement                      shift and go to state 124
    expression_statement           shift and go to state 80
    var_decl                       shift and go to state 81
    if_statement                   shift and go to state 83
    while_statement                shift and go to state 84
    for_statement                  shift and go to state 85
    return_statement               shift and go to state 86
    block                          shift and go to state 87
    expression                     shift and go to state 88
    type                           shift and go to state 89
    primary                        shift and go to state 21
    function_call                  shift and go to state 26

state 124

    (33) for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .

    RBRACE          reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    SEMICOLON       reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    IF              reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    WHILE           reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    FOR             reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    RETURN          reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    LBRACE          reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    NOT             reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    MINUS           reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    LPAREN          reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    IDENTIFIER      reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    INT             reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    FLOAT           reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    CHAR_TYPE       reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    VOID            reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    INTEGER         reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    FLOAT_NUMBER    reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    STRING          reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    CHAR            reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)
    ELSE            reduce using rule 33 (for_statement -> FOR LPAREN for_init SEMICOLON for_cond SEMICOLON for_update RPAREN statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 52 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 52 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 52 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 52 resolved as shift
WARNING: shift/reduce conflict for EQ in state 52 resolved as shift
WARNING: shift/reduce conflict for NE in state 52 resolved as shift
WARNING: shift/reduce conflict for LT in state 52 resolved as shift
WARNING: shift/reduce conflict for GT in state 52 resolved as shift
WARNING: shift/reduce conflict for LE in state 52 resolved as shift
WARNING: shift/reduce conflict for GE in state 52 resolved as shift
WARNING: shift/reduce conflict for AND in state 52 resolved as shift
WARNING: shift/reduce conflict for OR in state 52 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 112 resolved as shift
